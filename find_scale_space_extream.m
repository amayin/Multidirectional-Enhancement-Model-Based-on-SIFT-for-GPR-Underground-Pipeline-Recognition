function [key_point_array]=find_scale_space_extream....
    (dog_pyramid,...
    nOctaves,...
    nOctaveLayers,....
    contrast_threshold,....
    sigma,...
    edge_threshold,...
    gaussian_gradient,...
    gaussian_angle,...
    edge_detect...
    )

LOG_POLAR_HIST_BINS=36;%% bin nums
n=LOG_POLAR_HIST_BINS;

key_point_array=struct('x',{},'y',{},'octaves',{},'layer',{},...
     'xi',{},'size',{},'angle',{},'gradient',{});
num=0;

threshold=contrast_threshold/nOctaveLayers;

SIFT_IMG_BORDER=2;% Boundary constant, at least ==2
SIFT_ORI_PEAK_RATIO=0.8;%Histogram peak ratio

for i=1:1:nOctaves
    for j=2:1:nOctaveLayers+1   % j:dog金字塔中的层数
        current_dog=dog_pyramid{i,j};
        prev_dog=dog_pyramid{i,j-1};
        next_dog=dog_pyramid{i,j+1};
        [M,N]=size(current_dog);
        
        for r=SIFT_IMG_BORDER:1:M-SIFT_IMG_BORDER%%row
            for c=SIFT_IMG_BORDER:1:N-SIFT_IMG_BORDER%%col
                val=current_dog(r,c);
                
                if(abs(val)>threshold &&...  % If this point > the 26 neighbor point or < the 26 neighbor point
                    ((val>0 && val>=current_dog(r,c-1) && val>=current_dog(r,c+1)...
                     && val>=current_dog(r-1,c-1) && val>=current_dog(r-1,c)...
                     && val>=current_dog(r-1,c+1) && val>=current_dog(r+1,c-1)...
                     && val>=current_dog(r+1,c) && val>=current_dog(r+1,c+1)...
                     && val>=prev_dog(r-1,c-1) && val>=prev_dog(r-1,c)...
                     && val>=prev_dog(r-1,c+1) && val>=prev_dog(r,c-1)...
                     && val>=prev_dog(r,c) && val>=prev_dog(r,c+1)...
                     && val>=prev_dog(r+1,c-1) && val>=prev_dog(r+1,c)...
                     && val>=prev_dog(r+1,c+1)...
                     && val>=next_dog(r-1,c-1) && val>=next_dog(r-1,c)...
                     && val>=next_dog(r-1,c+1) && val>=next_dog(r,c-1)...
                     && val>=next_dog(r,c) && val>=next_dog(r,c+1)...
                     && val>=next_dog(r+1,c-1) && val>=next_dog(r+1,c)...
                     && val>=next_dog(r+1,c+1))...
                     || (val<0 && val<=current_dog(r,c-1) && val<=current_dog(r,c+1)...
                     && val<=current_dog(r-1,c-1) && val<=current_dog(r-1,c)...
                     && val<=current_dog(r-1,c+1) && val<=current_dog(r+1,c-1)...
                     && val<=current_dog(r+1,c) && val<=current_dog(r+1,c+1)...
                     && val<=prev_dog(r-1,c-1) && val<=prev_dog(r-1,c)...
                     && val<=prev_dog(r-1,c+1) && val<=prev_dog(r,c-1)...
                     && val<=prev_dog(r,c) && val<=prev_dog(r,c+1)...
                     && val<=prev_dog(r+1,c-1) && val<=prev_dog(r+1,c)...
                     && val<=prev_dog(r+1,c+1)...
                     && val<=next_dog(r-1,c-1) && val<=next_dog(r-1,c)...
                     && val<=next_dog(r-1,c+1) && val<=next_dog(r,c-1)...
                     && val<=next_dog(r,c) && val<=next_dog(r,c+1)...
                     && val<=next_dog(r+1,c-1) && val<=next_dog(r+1,c)...
                     && val<=next_dog(r+1,c+1))))
                 
                    r1=r;c1=c;layer=j;%2<=layer<=nOctaveLayers+1
                    [key_point,is_local_extream]=adjust_local_extream...  % 调整极值点位置
                        (dog_pyramid,i,layer,r1,c1,nOctaveLayers,sigma,...
                        contrast_threshold,edge_threshold,edge_detect);
                    if(is_local_extream==false)
                        continue;
                    end
                    
                    scl_octv=key_point.size/(2^(key_point.octaves-1));%Relative to this group
                    y=key_point.y/(2^(key_point.octaves-1));%Relative to this group
                    x=key_point.x/(2^(key_point.octaves-1));%Relative to this group
                    y=round(y);x=round(x);
                    
                    %The direction histogram of points
                    [hist,max_value]=calculate_oritation_hist...
                        (x,...%col
                        y,...%row
                        scl_octv,...%sacle
                        gaussian_gradient{key_point.octaves,key_point.layer-1},...
                        gaussian_angle{key_point.octaves,key_point.layer-1},...
                        n);
                    % 副方向阈值，大于该阈值则有副方向
                     mag_thr=max_value*SIFT_ORI_PEAK_RATIO;
                     % 取合角
%                      [main_oritation,main_gradient] = oritation_fusion(n,hist);
%                      sec_hist = hist;
%                      sec_hist(main_oritation) = 0;
%                      [sec_oritation,sec_gradient] = oritation_fusion(n,sec_hist);
                     for k=1:1:n
                         if(k==1)
                             k1=n;
                         else
                             k1=k-1;
                         end
                         
                         if(k==n)
                             k2=1;
                         else
                             k2=k+1;
                         end
                         
                         
                         % 当某方向大于阈值且周围没有更大梯度的方向时，设定为相同位置，不同方向的独立关键点
                         if(hist(k)>hist(k1) && hist(k)>hist(k2)...
                                 && hist(k)>mag_thr)
                            bin=k-1+0.5*(hist(k1)-hist(k2))/(hist(k1)+hist(k2)-2*hist(k));
                            if(bin<0)
                                bin=n+bin;
                            elseif(bin>=n)
                                bin=bin-n;
                            end
                            key_point.angle=(360/n)*bin;%转化到0-360之间
                            key_point.gradient=hist(k);
                            num=num+1;
                            key_point_array(num)=key_point;
                         end
                     end
                end
            end
        end
    end
end
end